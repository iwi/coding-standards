[
["index.html", "Data Science Campus Project Standards Preface", " Data Science Campus Project Standards Nathan Eastwood 2017-04-05 Preface The purpose of this document is to define correct coding standards and project best practices to be used within the Data Science Campus (DSC) at the Office for National Statistics (ONS). "],
["deps.html", "1 Dependency Management", " 1 Dependency Management Dependency management systems are incredibly important, particularly in the world of analysis. Whenever we produce some code to perform statistical analysis or machine learning, we need to be able to recreate those results exactly. This could be the day after or the year after and we need to know which versions of which packages we must have installed on our machine. Updates to packages can produce breaking changes and our code may produce slightly different results, or worse yet, not run at all. Then installing a specific packages for a certain project may make code on other projects break. That results can change so much with different pkg versions is scary (and ignored by many) https://t.co/wn5x3UBgQz #rstats #reproducibility pic.twitter.com/Jp4ASOKC81 — F Rodriguez-Sanchez (@frod_san) 29 March 2017 Moreover, you may be presented with someone else’s code but without them explicitly stating which packages you need, it is not always obvious, and even then you still have the manual challenge of installing the correct versions of each package yourself. These packages may then end up being globally installed when you don’t need them for any other project, therefore clogging up your system. "],
["introduction.html", "2 Introduction", " 2 Introduction This is a test "],
["programming-languages.html", "3 Programming languages 3.1 R 3.2 Code packaging 3.3 Python 3.4 Haskell 3.5 Scala 3.6 Java", " 3 Programming languages Make pretty code. No exceptions. 3.1 R 3.1.1 Tools goodpractice: Give advice about good practices when building R packages. Advice includes functions and syntax to avoid, package structure, code complexity, code formatting, etc. lintr: Static code analysis for R. Can be executed standalone/part of build or integrated into rstudio, emacs/ess, vim etc. formatr: Format R code automatically. 3.1.2 Links Hadley Wickham’s R Style Guide Code Golf :) 3.2 Code packaging When writing code for a project, that code should ideally be held within a self contained package or series of packages. This helps to manage dependencies on other packages, code testing, documentation and more. For R, there is one major resource that you should make yourself familiar with: http://r-pkgs.had.co.nz/. This book should cover all the essentials you will need to know in order to write an R package. Once you have mastered this book, you may wish to consider the Writing R Extensions manual, though this is a heavy read. 3.2.1 Code testing testthat 3.2.2 Dependency management Keeping track of dependencies in R can be a chore, particularly when using lots of different packages such as those belonging to the tidyverse. There are however different packages which aim to help with this. 3.2.2.1 DESCRIPTION file This is the most basic way of maintanining dependencies in R, though it is not recommended - it is only part of the dependency management system you should employ. Each R package will have a DESCRIPTION file which should contain a list of packages your package Depends on, Imports and Suggests. You can specify certain versions within for each of these. 3.2.2.2 packrat packrat is a dependency management system for R. Use packrat to make your R projects more: Isolated: Installing a new or updated package for one project won’t break your other projects, and vice versa. That’s because packrat gives each project its own private package library. Portable: Easily transport your projects from one computer to another, even across different platforms. packrat makes it easy to install the packages your project depends on. Reproducible: packrat records the exact package versions you depend on, and ensures those exact versions are the ones that get installed wherever you go. See the project page for more information. 3.2.2.3 pkgsnap pkgsnap is a more lightweight alternative to packrat which allows you to backup and restore certain CRAN package versions. pkgsnap will create a snapshot of your installed CRAN packages with snap(), and then use restore() on another system to recreate exactly the same environment. Unfortunately pkgsnap isn’t heavily developed. 3.3 Python 3.3.1 Code testing nosetools pytest 3.4 Haskell 3.5 Scala 3.6 Java "],
["tools-1.html", "4 Tools 4.1 GitHub 4.2 Docker", " 4 Tools 4.1 GitHub Few software engineering projects will begin without some form of version control and data science should be no different. Version control software allows us to track the three Ws: Who made Which change, and Why? There are various different version control tools such as Git, SVN and Mercurial, however within the Data Science Campus we use git as our version control software of choice. Git can be used locally on a single machine, on many networked machines or connected to many online repository services such as GitHub, GitLab and BitBucket. Each of these services provides hosting for your version control repository, and makes the code open and easy to share with the world, or if necessary, private and shared with the Campus team only. We use GitHub within the Campus and have an organisation account which allows us to use private repositories, please speak to another member of staff about getting help in joining the organisation. 4.1.1 Naming conventions All GitHub repository names should follow the kebab-case naming convention and be in lower case. 4.1.2 Commit best practices Ideally, each commit should be minimal but complete. They should aim to solve a single specific problem with your code. This makes commits that you make much easier to understand but it also makes it easier to undo commits should you make an error. Leaving all commits until the end of the day is a bad idea as rather than being able to undo a single issue, you may lose an entire day’s work to solve your problem. When you think you have solved a bug, it is always a good idea to include a test to confirm you are correct. Each commit message should be concise but present a clear message about what the commit achieved. There should be enough detail so you can remember (and understand) what was done. Ideally you should describe the why but not the what. Figure 4.1: Try to keep git commit messages as informative as possible Sticking to these standards will make it much easier to work with others. For example, if two people have changed the same file in the same place, it’ll be easier to resolve conflicts if the commits are small and it’s clear why each change was made and project newcomers can more easily understand the history by reading the commit logs. More importantly, if you can figure out exactly when a bug was introduced, you can easily understand what you were doing (and why!). Some really good advice is: You might think that because no one else will ever look at your repo, that writing good commit messages is not worth the effort. But keep in mind that you have one very important collaborator: future-you! If you spend a little time now polishing your commit messages, future-you will thank you if and when they need to do a post-mortem on a bug. 4.2 Docker Rocker "],
["templates.html", "5 Templates 5.1 R", " 5 Templates 5.1 R Applications and packages should use the built in project templates from RStudio. An Emacs skeletor.el package is available here "]
]
